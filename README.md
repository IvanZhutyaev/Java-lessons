# Java-lessons
My java lessons

## Java-компилятор
- Байт-код - нужен для кроссплатформенности, производительности
- JVM - позволяет выполнять скомпилированный java код на каждой ОС
- Сборщик мусора в JVM - автоматически освобождает память (переменные, которые просто забивают ЦП)
- JRE - Java Runtime Environment - среда выполнения java

## Иерархия Java
JVM совместно со стандартными Java-библиотеками образует Среду Выполнения Java (JRE)

```
JDK (Java development kit + инструменты для Java-разработчиков)
↓
JRE (Java Runtime Environment + набор стандартных Java-библиотек)
↓
JVM (Java Virtual Machine)
```

## Быстрые команды
- `sout` → `System.out.println("Hello world");`
- `psvm` → `public static void main(){}`

## Форматированный вывод
```java
System.out.format("Hello. My name is %s, i am %d years old ", name, age);
```

`System` - класс, который позволяет разработчику возможность общение с окружающей его средой - ОС

## Константы
Константа объявляется ключевым словом - `final`:
```java
final int LIMIT = 5;
```
Название констант в Java - БОЛЬШИМИ БУКВАМИ

## Деление чисел
При делении целого числа на целое получится ЦЕЛОЕ ЧИСЛО
При делении числа с вещественным типом данных получится обычное деление:

```java
int a = 5;
int b = 2;
float c = 2;
System.out.print(a/b);  // 2
System.out.print(a/c);  // 2.5
```

## Приведение типов
При явной конвертации большего типа данных к меньшему происходит потеря данных, лишние биты отбрасываются
```java
int a = 258;
byte b = (byte) a;  // 2
```

## Ввод данных:
```java
Scanner console = new Scanner(System.in);
String name = console.nextLine();
int age = console.nextInt();
```

## Сравнение строк
`.equals` ↔ `==` (касается строк) - СРАВНИВАЕТ ПО ЗНАЧЕНИЮ

## Switch
```java
int a = 5;
switch (a) {
    case 1:
        System.out.println("1");
    case 2:
        System.out.println("2");
    case 3:
        System.out.println("3");
    default:
        System.out.println("default");
}
```

## Тернарная операция:
```java
z = (x < y) ? x + y : x - y;
```
- `(x < y)` - условие
- `?` - если
- `x + y` - если true
- `x - y` - если false

## ЦИКЛЫ
- `break` - остановить цикл
- `continue` - пропустить круг и перейти к другому кругу

## String
### Классы строк: String, StringBuffer, StringBuilder

### class String:
- У класса String не может быть наследников (`final`)
- Экземпляры класса нельзя изменить после создания (`immutable`)
- При изменении строки создаются КОПИИ

```java
String a = "111"  // 1 ячейка
a = "222"         // 2 ячейка
```

### Строки могут быть:
**ЛИТЕРАЛЛАМИ:**
```java
String s1 = "Hello"
```

**ЛИБО СТРОКОВЫМИ ОБЪЕКТАМИ:**
```java
String s1 = new String("Hello")
```

- Строковые литералы с одинаковым значением указывает на один и тот же объект в памяти
- Строковые объекты с одинаковым значением указывают на разные объекты в памяти

`==` сравнивает адреса в памяти (ссылки)
`.equals` сравнивает значения в памяти

### Методы String:
- `length()` - длина строки
- `concat(String)` - сложение строк (аналог +)
- `indexOf(String)` - найти индекс позиции первого элемента в строке
- `substring(..)` - получить подстроку (по факту вырезать кусок)

### class StringBuffer:
- Уже изменяемый
```java
StringBuffer sb2 = new StringBuffer("Not empty")
```
- `append` - метод для конкатенации (просто так перезаписать строку не получится!!!)
- `StringBuffer.append` можно добавить любой тип данных
- StringBuffer - изменяемый класс, поэтому при работе с ним не возникает такого же количества мусора в памяти, как со String
- StringBuffer - потокобезопасный класс. Его методы синхронизированы, а экземпляры могут быть использованы несколькими потоками одновременно
- Синхронизированные методы работают медленнее не синхронизированных

### class StringBuilder:
- Отсутствует потокобезопасность
- Более быстрый чем StringBuffer

## Регулярное выражение
Шаблон для строк

```java
String a = "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$";
```

По факту проверка на валидность строки по шаблону (стандарту)
Как пример: регулярное выражение для email/телефона

### Разделение строки:
```java
String[] words = text.split("\\s*(\\s|,|!|\\.)\\s*");
```
Метод `split` применяется для разделения строки

### Pattern и Matcher:
```java
Pattern pattern = Pattern.compile("bob");
Matcher matcher = pattern.matcher("bob1");
System.out.println(matcher.find());     // true (ищет любое совпадение)
System.out.println(matcher.matches());  // false (смотрит в общем всю строку)
```

```java
Pattern pattern = Pattern.compile("bob");
Matcher matcher = pattern.matcher("aboba aboba aboba");
while(matcher.find())  // ищет любое совпадение
    System.out.println(matcher.group());  // bob bob bob (группирует ответ)
```

- `matcher.matches()` - любое вхождение подстроки в строке должно совладать с регулярным выражение
- `matcher.find()` - полное совпадение строки на регулярное выражение

## Массивы
### Вариант создания:
```java
int nums[] = new int[4];
int[] nums1 = new int[5];
int[] nums2 = {1, 2, 3, 4, 5};
int[] nums3 = new int[] {1, 2, 3};
```

## ФУНКЦИИ
Обособленный участок кода, который вызывается по имени.

### Функции бывают:
- Возвращающая без параметров
- Возвращающая с параметрами
- НЕвозвращающая без параметров
- НЕвозвращающая с параметрами

### Перегрузка методов
В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров.

## Обработка исключений:
`try...catch...finally`

- `try` - потенциальная ошибка
- `catch` - действие, если поймали ошибку
- `finally` - выполнится в любом случае

В начале выполняются все инструкции между операторами try и catch. Если в блоке try вдруг возникает исключение, то обычный порядок выполнения останавливается и переходит к инструкции catch.

При обработке разных типов исключений в блоках catch необходимо использовать уникальные классы ошибок!

Блок finally выполняется в любом случае, возникло ли исключение в блоке try или нет.

- Оператор `throw` - выбросить исключение вручную
- Оператор `throws` - позволяет пробросить обработку исключений вверх по стеку

## Enum - перечисления
Набор константных значений

Если энумератор является отдельным классом, то нельзя использовать модификатор `private`

Если enum является частью класса - любой модификатор

### Методы Enum:
- `.values()` - предоставляет массив констант энумератора
- `.name()` - имя константы перечисления
- `.ordinal()` - порядковый номер константы энумератора
- `.valueOf()` - позволяет получить значение константы перечисления по его строковому представлению

Поля и методы в перечислениях как и в классах могут иметь модификаторы доступа `private`, `protected`, `default`, `public`, а вот конструкторы в перечислениях всегда будут иметь модификатор `private`

`@Override` - показывает, что будет переопределение от класса-родителя

## Работа с файлами в JAVA
- класс `FileWriter` - создание и запись файла
- класс `FileReader` - считывание файла

```java
FileWriter fw = new FileWriter("MyFile.txt")
FileReader fr = new FileReader("MyFile.txt")
```

При создании объекта FileWriter, если файла нет - создаётся автоматически, если есть - записывает в него

Всегда нужно закрывать поток!!!
```java
fw.close()
fr.close()
```

FileWriter/FileReader - это потоки, их нужно не только "открыть" (то-есть объявить), но и "закрыть"

```java
fw.write("Hello")  // запись в текстовый файл (перезапись)
```

Записывать в текстовый файл можно только текст!!!

```java
fw.append("sads")  // дописать файл
```

`ALT+Insert` - автогенерация

## Абстрактные классы
Абстрактные классы - это принцип ООП, согласно которому при проектировании классов и создании объектов необходимо выделять только главные свойства сущности, и отбрасывать второстепенные.

НЕЛЬЗЯ СОЗДАВАТЬ ОБЪЕКТ АБСТРАКТНОГО КЛАССА!!!

Класс является абстрактным, если хотя бы один из его методов является абстрактным!

Если метод помечен словом `abstract`, каждый класс-наследник должен его реализовать или быть объявленным как абстрактный. Иначе компилятор выбросит ошибку.

Абстрактные классы и перечисления похожи, но интерфейс описывает только поведение, у него есть состояния, а у абстрактного класса состояние есть: он описывает и то, и другое.

## ИНТЕРФЕЙСЫ JAVA
Интерфейсы позволяют делать множественную реализацию

Чтобы класс применил интерфейс, надо использовать ключевое слово `implements`
```
